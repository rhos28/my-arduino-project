#include <Arduino.h>
#include "BluetoothSerial.h"
#include "driver/timer.h"

// --- تنظیمات قابل تغییر توسط کاربر ---
const int NUM_DEVICES_CH1 = 16;  // 16 نمایشگر در کانال اول
const int NUM_DEVICES_CH2 = 16;  // 16 نمایشگر در کانال دوم
// ------------------------------------

// پین‌های اتصال به 74HC595 - کانال اول (ESP32 DevKit V1)
const int dataPin1 = 13;   // GPIO13
const int latchPin1 = 12;  // GPIO12
const int clockPin1 = 14;  // GPIO14

// پین‌های اتصال به 74HC595 - کانال دوم (ESP32 DevKit V1)
const int dataPin2 = 27;   // GPIO27
const int latchPin2 = 26;  // GPIO26
const int clockPin2 = 25;  // GPIO25

// محاسبه خودکار مقادیر بر اساس تنظیمات
const int TOTAL_DEVICES = NUM_DEVICES_CH1 + NUM_DEVICES_CH2;
const int CHANNEL2_OFFSET = NUM_DEVICES_CH1;

// الگوی اعداد برای آند مشترک (0 روشن = LOW)
const byte numbers[10] PROGMEM = {
  0b11000000, // 0
  0b11111001, // 1
  0b10100100, // 2
  0b10110000, // 3
  0b10011001, // 4
  0b10010010, // 5
  0b10000010, // 6
  0b11111000, // 7
  0b10000000, // 8
  0b10010000  // 9
};

// تنظیمات مالتیپلکسینگ
const int REFRESH_RATE_HZ = 600; // افزایش فرکانس برای ESP32
volatile int currentDigit = 0;
volatile bool refreshFlag = false;

// بافرهای داده برای هر دو کانال
byte digitData[TOTAL_DEVICES][7];

// متغیرهای انیمیشن
bool isAnimating = false;
unsigned long animationStartTime = 0;
const unsigned long ANIMATION_DURATION = 5000;
const int ANIMATION_CYCLES = 3;

// شیء بلوتوث
BluetoothSerial SerialBT;

// پیش‌تعریف توابع
void processSerialCommands();
void refreshAllDisplays();
void showCurrentBuffer();
void setupTimer();
void clearAllDisplays();
void startAnimation(int device, const char* number);
void updateAnimation();
void sendToBluetooth(const String& message);
void processCommand(String command, bool fromBluetooth);

// توابع بهینه‌شده برای مالتیپلکسینگ
void IRAM_ATTR fastDigitalWrite(uint8_t pin, uint8_t val);
void IRAM_ATTR fastSendToShiftRegister(uint8_t data, uint8_t channel);
void IRAM_ATTR fastRefreshAllDisplays();

// تابع وقفه تایمر
void IRAM_ATTR onTimer() {
  refreshFlag = true;
}

void setup() {
  // تنظیم پین‌های کانال اول
  pinMode(dataPin1, OUTPUT);
  pinMode(latchPin1, OUTPUT);
  pinMode(clockPin1, OUTPUT);
  
  // تنظیم پین‌های کانال دوم
  pinMode(dataPin2, OUTPUT);
  pinMode(latchPin2, OUTPUT);
  pinMode(clockPin2, OUTPUT);
  
  // مقداردهی اولیه پین‌ها
  digitalWrite(dataPin1, LOW);
  digitalWrite(latchPin1, LOW);
  digitalWrite(clockPin1, LOW);
  digitalWrite(dataPin2, LOW);
  digitalWrite(latchPin2, LOW);
  digitalWrite(clockPin2, LOW);

  // راه اندازی تایمر برای مالتیپلکسینگ
  setupTimer();

  // راه اندازی بلوتوث
  SerialBT.begin("ESP32-Display");
  Serial.begin(115200);
  
  // مقداردهی اولیه بافر
  clearAllDisplays();
  
  // ارسال پیام خوش‌آمدگویی
  sendToBluetooth("=== 32x7-Digit Display Controller ===");
  sendToBluetooth("Bluetooth: ESP32-Display");
  sendToBluetooth("Optimized Multiplexing - Refresh: " + String(REFRESH_RATE_HZ) + "Hz");
  sendToBluetooth("Ready for commands...");
}

void loop() {
  processSerialCommands();

  // بررسی فلگ رفرش از تایمر
  if (refreshFlag) {
    refreshFlag = false;
    fastRefreshAllDisplays(); // استفاده از تابع بهینه‌شده
  }

  // بروزرسانی انیمیشن اگر فعال باشد
  if (isAnimating) {
    updateAnimation();
  }
}

// --- ارسال پیام به بلوتوث ---
void sendToBluetooth(const String& message) {
  SerialBT.println(message);
  Serial.println(message);
}

// --- تنظیم تایمر برای مالتیپلکسینگ ---
void setupTimer() {
  // استفاده از تایمر سخت‌افزاری ESP32
  hw_timer_t *timer = timerBegin(0, 80, true); // تایمر 0، تقسیم بر 80 (1MHz)
  timerAttachInterrupt(timer, &onTimer, true);
  
  // محاسبه interval برای فرکانس مورد نظر
  // فرکانس = 1MHz / interval = 600Hz → interval = 1666
  int interval = 1000000 / REFRESH_RATE_HZ; 
  timerAlarmWrite(timer, interval, true);
  timerAlarmEnable(timer);
}

// --- تابع سریع برای DigitalWrite ---
void IRAM_ATTR fastDigitalWrite(uint8_t pin, uint8_t val) {
  if (pin < 32) {
    if (val) 
      GPIO.out_w1ts = (1 << pin);
    else 
      GPIO.out_w1tc = (1 << pin);
  } else {
    if (val) 
      GPIO.out1_w1ts.val = (1 << (pin - 32));
    else 
      GPIO.out1_w1tc.val = (1 << (pin - 32));
  }
}

// --- تابع سریع برای ارسال به شیفت رجیستر ---
void IRAM_ATTR fastSendToShiftRegister(uint8_t data, uint8_t channel) {
  uint8_t dataPin, clockPin;
  
  if (channel == 1) {
    dataPin = dataPin1;
    clockPin = clockPin1;
  } else {
    dataPin = dataPin2;
    clockPin = clockPin2;
  }
  
  // ارسال داده به صورت بیت به بیت با سرعت بالا
  for (int i = 7; i >= 0; i--) {
    fastDigitalWrite(dataPin, (data >> i) & 1);
    fastDigitalWrite(clockPin, 1);
    fastDigitalWrite(clockPin, 0);
  }
}

// --- تابع سریع برای رفرش همه نمایشگرها ---
void IRAM_ATTR fastRefreshAllDisplays() {
  // غیرفعال کردن لچ همزمان با سریع‌ترین روش
  uint32_t latch_mask1 = (1 << latchPin1);
  uint32_t latch_mask2 = (1 << latchPin2);
  GPIO.out_w1tc = latch_mask1 | latch_mask2;
  
  // ارسال داده برای کانال اول
  for (int device = NUM_DEVICES_CH1 - 1; device >= 0; device--) {
    byte digitMask = ~(1 << currentDigit);
    fastSendToShiftRegister(digitMask, 1);
    fastSendToShiftRegister(digitData[device][currentDigit], 1);
  }
  
  // ارسال داده برای کانال دوم
  for (int device = NUM_DEVICES_CH2 - 1; device >= 0; device--) {
    byte digitMask = ~(1 << currentDigit);
    fastSendToShiftRegister(digitMask, 2);
    
    int actualDevice = device + CHANNEL2_OFFSET;
    byte data = (actualDevice < TOTAL_DEVICES) ? digitData[actualDevice][currentDigit] : 0xFF;
    fastSendToShiftRegister(data, 2);
  }
  
  // فعال کردن لچ همزمان
  GPIO.out_w1ts = latch_mask1 | latch_mask2;
  
  // افزایش رقم جاری
  currentDigit = (currentDigit + 1) % 7;
}

// --- پاک کردن همه نمایشگرها ---
void clearAllDisplays() {
  for (int device = 0; device < TOTAL_DEVICES; device++) {
    for (int digit = 0; digit < 7; digit++) {
      digitData[device][digit] = 0xFF; // خاموش
    }
  }
}

// --- شروع انیمیشن ---
void startAnimation(int device, const char* number) {
  if (device >= 0 && device < TOTAL_DEVICES) {
    isAnimating = true;
    animationStartTime = millis();
    
    sendToBluetooth("Starting animation on device " + String(device));
    sendToBluetooth("Number: " + String(number));
  }
}

// --- بروزرسانی انیمیشن ---
void updateAnimation() {
  unsigned long currentTime = millis();
  unsigned long elapsedTime = currentTime - animationStartTime;
  
  if (elapsedTime >= ANIMATION_DURATION) {
    isAnimating = false;
    sendToBluetooth("Animation finished");
    return;
  }
  
  float progress = (float)elapsedTime / ANIMATION_DURATION;
  int currentCycle = (int)(progress * ANIMATION_CYCLES);
  float cycleProgress = (progress * ANIMATION_CYCLES) - currentCycle;
  
  int animatingDevice = 0;
  
  // پاک کردن دستگاه انیمیشنی
  for (int digit = 0; digit < 7; digit++) {
    digitData[animatingDevice][digit] = 0xFF;
  }
  
  // انیمیشن حرکت از راست به چپ
  if (cycleProgress < 0.7) {
    int shiftAmount = (int)(cycleProgress * 10);
    for (int i = 0; i < 7; i++) {
      int displayDigit = i - shiftAmount;
      if (displayDigit >= 0 && displayDigit < 7) {
        int numberToShow = (currentCycle + i) % 10;
        digitData[animatingDevice][displayDigit] = pgm_read_byte(&numbers[numberToShow]);
      }
    }
  } else {
    for (int digit = 0; digit < 7; digit++) {
      int numberToShow = (currentCycle + digit) % 10;
      digitData[animatingDevice][digit] = pgm_read_byte(&numbers[numberToShow]);
    }
  }
}

// --- پردازش دستورات از بلوتوث ---
void processSerialCommands() {
  if (SerialBT.available()) {
    String command = SerialBT.readStringUntil('\n');
    command.trim();
    command.toUpperCase();
    processCommand(command, true);
  }
  else if (Serial.available()) {
    String command = Serial.readStringUntil('\n');
    command.trim();
    command.toUpperCase();
    processCommand(command, false);
  }
}

// --- پردازش دستور ---
void processCommand(String command, bool fromBluetooth) {
  auto sendResponse = [&](const String& message) {
    if (fromBluetooth) {
      SerialBT.println(message);
    }
    Serial.println(message);
  };

  if (command.startsWith("SET")) {
    int device, digit, number;
    if (sscanf(command.c_str(), "SET %d %d %d", &device, &digit, &number) == 3) {
      if (device >= 0 && device < TOTAL_DEVICES && digit >= 0 && digit < 7 && number >= 0 && number <= 9) {
        digitData[device][digit] = pgm_read_byte(&numbers[number]);
        sendResponse("OK: Device " + String(device) + " Digit " + String(digit) + " = " + String(number));
      } else {
        sendResponse("ERROR: SET [0-" + String(TOTAL_DEVICES-1) + "] [0-6] [0-9]");
      }
    } else {
      sendResponse("ERROR: Bad syntax - SET [device] [digit] [number]");
    }
  }

  else if (command.startsWith("DEVICE")) {
    int device;
    char numStr[9];
    
    char* token = strtok((char*)command.c_str(), " ");
    token = strtok(NULL, " ");
    if (token == NULL) {
      sendResponse("ERROR: Missing device number");
      return;
    }
    device = atoi(token);
    
    token = strtok(NULL, " ");
    if (token == NULL) {
      sendResponse("ERROR: Missing number");
      return;
    }
    strncpy(numStr, token, 8);
    numStr[8] = '\0';
    
    if (device >= 0 && device < TOTAL_DEVICES) {
      int len = strlen(numStr);
      
      for (int i = 0; i < len && i < 7; i++) {
        char c = numStr[len - 1 - i];
        int digitIndex = 6 - i;
        
        if (digitIndex >= 0 && isdigit(c)) {
          int number = c - '0';
          digitData[device][digitIndex] = pgm_read_byte(&numbers[number]);
        }
      }
      
      String result = "OK: Device " + String(device) + " = ";
      for (int digit = 0; digit < 7; digit++) {
        byte val = digitData[device][digit];
        bool found = false;
        for (int n = 0; n < 10; n++) {
          if (val == pgm_read_byte(&numbers[n])) {
            result += String(n);
            found = true;
            break;
          }
        }
        if (!found) result += '-';
      }
      sendResponse(result);
      
    } else {
      sendResponse("ERROR: Device number must be between 0 and " + String(TOTAL_DEVICES-1));
    }
  }

  else if (command.startsWith("ALL")) {
    int number;
    if (sscanf(command.c_str(), "ALL %d", &number) == 1) {
      if (number >= 0 && number <= 9) {
        for (int device = 0; device < TOTAL_DEVICES; device++) {
          for (int digit = 0; digit < 7; digit++) {
            digitData[device][digit] = pgm_read_byte(&numbers[number]);
          }
        }
        sendResponse("OK: All displays = " + String(number));
      } else {
        sendResponse("ERROR: ALL [0-9] - Number must be between 0 and 9");
      }
    } else {
      sendResponse("ERROR: Bad syntax - ALL [number]");
    }
  }

  else if (command.startsWith("ANIMATE")) {
    int device;
    char numStr[9];
    
    char* token = strtok((char*)command.c_str(), " ");
    token = strtok(NULL, " ");
    if (token == NULL) {
      sendResponse("ERROR: Missing device number");
      return;
    }
    device = atoi(token);
    
    token = strtok(NULL, " ");
    if (token == NULL) {
      sendResponse("ERROR: Missing number");
      return;
    }
    strncpy(numStr, token, 8);
    numStr[8] = '\0';
    
    if (device >= 0 && device < TOTAL_DEVICES) {
      startAnimation(device, numStr);
      sendResponse("OK: Animation started on device " + String(device));
    } else {
      sendResponse("ERROR: Device number must be between 0 and " + String(TOTAL_DEVICES-1));
    }
  }

  else if (command == "CLEAR") {
    clearAllDisplays();
    isAnimating = false;
    sendResponse("OK: All displays cleared");
  }

  else if (command == "SHOW") {
    String status = "=== Display Status ===\n";
    for (int device = 0; device < TOTAL_DEVICES; device++) {
      status += "Device " + String(device) + ": ";
      for (int digit = 0; digit < 7; digit++) {
        byte val = digitData[device][digit];
        bool found = false;
        for (int n = 0; n < 10; n++) {
          if (val == pgm_read_byte(&numbers[n])) {
            status += String(n);
            found = true;
            break;
          }
        }
        if (!found) status += '-';
        if (digit < 6) status += ' ';
      }
      status += "\n";
    }
    status += "=====================";
    sendResponse(status);
  }

  else if (command == "HELP" || command == "?") {
    sendResponse("=== Available Commands ===");
    sendResponse("SET [device] [digit] [number]");
    sendResponse("DEVICE [device] [7-digit-number]");
    sendResponse("ALL [number]");
    sendResponse("ANIMATE [device] [number]");
    sendResponse("CLEAR, SHOW, HELP");
  }

  else {
    sendResponse("ERROR: Unknown command. Type HELP for available commands.");
  }
}
